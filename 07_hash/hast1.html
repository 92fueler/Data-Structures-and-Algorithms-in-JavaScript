<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Hash</title>
    </head>

    <body>
        <h1>哈希表的效率</h1>
        <p>
            哈希表执行插入和搜索操作效率是非常高的<br>
            如果没有产生冲突，那么效率就会更高<br>
            如果发生冲突，存取时间就依赖后来的探测长度．<br>
            平均探测长度以及平均存取时间，取决于填装银子，随着填装因子变大，探测长度也越来越长．<br>
            随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重，所以我们来对比一下他们的效率，再决定我们选取的方案<br>
        </p>
        <p>
            在分析效率之前，我们先了解一个概念：装填因子 load factor <br>
            装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值<br>
            装填因子　＝　总数据项　／　哈希表长度<br>
            开放地址法的装填因子最大是多少呢？１，因为它必须寻找到空白的单元才能将元素放入<br>
            链地址法的装填因子呢？可以大于１，因为拉链法可以无线的延伸下去，只要你愿意（当然，后面效率就变低了）<br>
        </p>
        <h1>链地址法</h1>
            <p>
                链地址法的效率分析有些不同，一般来说，比开放地址法简单，我们来分析一下这个公式应该是怎么样的：<br>
                加入哈希表包含arraySize个数据项，每个数据项有一个链表，在表中一共包含Ｎ个数据项<br>
                那么，平均起来每个链表有多少个数据项呢？非常简单，Ｎ/arraySize <br>
                其实这就是load factor装载因子<br>
            </p>
            <p>
                ＯＫ，那么我们现在就可以求出查找成功　和不成功的次数了：<br>
                成功可能只需要查找链表的一半即可：1 + loadFactor / 2 <br>
                不成功呢？可能需要将整个链表查询完才知道不成功：1 + loadFactor<br>
                经过上面的比较我们可以发现，链地址法相对来说效率是好于开放地址法的<br>
                所以在真实开发中，使用链地址法的情况较多<br>
                因为它不会因为添加了某元素性能急剧下降<br>
                比如，在Java的HashMap中使用的就是链地址法
            </p>
        <h1>优秀的哈希函数</h1>
        <p>
            讲了很久的哈希函数理论知识，一个非常重要的东西：哈希函数？<br>
            好的哈希函数应该尽可能让计算的过程变得简单，提高计算的效率<br>
            哈希表的主要优点是它的速度，所有在速递上不能满足，那么就达不到设计的目的了<br>
            提高速度的一个办法就是让哈希函数中尽量少的有乘法和除法，因为它们的性能是比较低的<br>
        </p>
        <h4>设计好的哈希函数应该具备哪些优点？</h4>
        <p>
            快速的计算<br>
            哈希表的优势就在于效率，所以快速获取到对应的hashCode非常重要<br>
            我们需要通过快速的计算来获取到元素对应的hashCode

            均匀的分布<br>
            哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候，都会影响效率<br>
            所以，优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布<br>
        </p>
    </body>
</html>