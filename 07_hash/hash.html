<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>哈希表</title>
        <style>
            strong {
                color: red;
            }
            
        </style>
    </head>
    <body>
        <div>
            <h1>哈希表是一种非常重要的数据结构</h1>
        </div>
        <div>
            <h4>数组的缺点</h4>
            <ol>
                <li>数组进行插入操作时，效率比较低</li>
                <li>数组进行查找操作的效率</li>
                    <ol>
                        <li> 如果是基于索引进行查找操作，效率非常高</li>
                        <li>基于内容去查找，效率低</li>
                    </ol>
                <li>数字进行删除操作，效率也不高</li>
            </ol>
        </div>
        <div>
            <h4>哈希表通常是基于数组进行直接或间接的应用这种数据结构，但是相对于数组，它也很多的优势：</h3>
            <ol>
                <li>可以提供非常快速的插入-删除-查找操作</li>
                <li>无论多少数据，插入和删除值需要接近常量的时间：即O(1)的时间级。实际上，只需要几个机器指令即可完成</li>
                <li>哈希表的速度比树还要快，基本可以瞬间查找到想要的元素</li>
                <li>哈希表相对于树来说，编码要容易很多</li>
            </ol>
        </div>
        <div>
            <h4>哈希表相对于数组的一些不足：</h4>
            <ol>
                <li><strong>哈希表中的数据是没有顺序的</strong>，所以不能以一种固定的方式(比如从小到大)来遍历其中的元素</li>
                <li>通常情况下，<strong>哈希表中的key是不允许重复的</strong>, 不能放置相同的Key，用于保存不同的元素</li>
            </ol>
        </div>
        <div>
            <h3>什么是哈希表？</h3>
            <ol>
                <li>哈希表不像数组和链表，甚至是树，不能直接画出结果</li>
                <li>它的结构就是数组，但是它神奇的地方在于<strong>对下标值的一种变换</strong>，这种变换称为<strong>哈希函数</strong>，通过哈希函数可以获取到HashCode </li>
            </ol>
        </div>
        <div>
            <h4>通过三个案例</h4>
            <ul>
                <li>案例一：公司使用一种数据结构来保存所有员工</li>
                <li>案例二： 设计一个数据结构，保存联系人和电话</li>
                <li>案例三： 使用一种数据结果存储单词信息，比如有500000个单词，找到单词后每个单词有自己的翻译 & 读音 &　应用</li>
            </ul>
        </div>
        <div>
            <h4>案例一介绍</h4>
            <ul>
                <li>假如一家公司有1000个员工,现在我们需要将这些员工的信息使用某种数据结果来保存起来</li>
                <li>你会采用什么数据结果</li>
            </ul>
            <h5>方案一: 数组</h5>
                <ul>
                    <li>按照顺序将所有的员工依次存入一个长度为1000的数组中,每个员工的信息都保存在数组的某个位置上</li>
                    <li>但是, 我们要查看某个具体员工的信息怎么办?一个一个找吗?不太好找</li>
                    <li>数组最大的优势是什么? 通过下标值去获取信息</li>
                    <li>所以,为了快速定位到某个员工,最好给员工信息中添加一个员工编号(工号), 而编号对应的就是员工的下标值.</li>
                    <li>当查找某个员工的信息时,通过员工编号可以快速定位到员工的信息位置</li>
                </ul>
            <h5>方案二: 链表</h5>
                <ul>
                    <li>链表对应插入和删除数据有一定的优势</li>
                    <li>但是,对于获取员工的信息,每次都必须从头遍历到尾,这种方式显然不是特别适合这里</li>
                </ul>
            <h5>最终方案:</h5>
                <ul>
                    <li>这样看最终方案似乎就是数组了.但是数组还是有缺点.</li>
                    <li>什么缺点呢? 假如我们想查看某一个员工,但是我们不知道他的工号,即不知道他在数组中对应的下标值</li>
                    <li>如果用线性查找, 效率就会很低</li>
                    <li>能不能有一种方法,让每个员工的名字和员工编号差生直接的关系呢?</li>
                    <li>也就是,通过这个员工的名字,我们就能获取到它的索引值,而再通过索引值,我们就能获取到这个员工的所有信息.</li>
                    <li><strong>这种方案,就是哈希函数 -- 让某个key的信息和索引值对应起来</strong></li>
                </ul>
        </div>
        <div>
            <h4>案例二介绍</h4>
            <p>选择一个数据结果,来组成电话簿</p>
            <h5>方案一: 数组</h5>
                <ul>
                    <li>使用数组来存储联系人和电话不是非常合适</li>
                    <li>查询太费时间</li>
                </ul>
            <h5>方案二: 链表</h5>
                <ul>
                    <li>链表对应插入和删除数据有一定的优势</li>
                    <li>但是,查询, 每次都必须从头遍历到尾,这种方式显然不是特别适合这里</li>
                </ul>
            <h5>最终方案:</h5>
                <ul>
                    <li>就是对数组方案的改进</li>
                    <li><strong>让联系人的名字作为下标值</strong>,来获取这个联系人对应的电话</li>
                    <li>但是联系人的名字(字符串)可以作为下标值吗? 当然不可以</li>
                    <li>所以,需要一种方案将字符串转成下标值,就是哈希函数</li>
                </ul>
        </div>
        <div>
            <h2>字母转数字的方案一</h2>
            <ul>
                <li>似乎所有的案例都指向了一目标：将字符串转成下标值</li>
                <li>但是，怎样才能将一个字符串转成数组的下标值呢？</li>
                <ul>
                    <li>单词／字符串转下标值，其实就是字母／文字转数字</li>
                    <li>怎么转呢？</li>
                </ul>
                <li>现在，我们需要设计一种方案，可以将单词转成适当的下标：</li>
                <ul>
                    <li>其实，计算机中很多的编码方案就是用数字代替单词的字符，就是字符编码</li>
                    <li>比如，ASCII编码</li>
                    <li>我们也可以设计一个自己的编码系统，比如a是１，b是２，c是３，依次类推，z是２６</li>
                    <li>当然，我们可以加上空格用０代替，就是２７个字符（不考虑大写问题）</li>
                    <li>但是，有了编码系统后，一个单词如何转成数字呢？</li>
                    <li>方案一</li>
                        <ul>
                            <li>一种转换单词的简单方案，就是把单词每个字符的编码求和</li>
                            <li>例如，单词cats转成数字：３＋１＋２０＋１９＝４３，那么，４３就作为cats单词的下标存在数组中</li>
                            <li>问题：按照这种方案，有一个明显的问题，就是很多单词最终的下标值都可能是４３</li>
                            <ul>
                                <li>比如，was/tin/give/tend/moan/tick等等</li>
                                <li>我们知道数组中一个下标值位置只能存储一个数据</li>
                                <li>如果存入后来的数据，必然会造成数据的覆盖</li>
                                <li>一个下标存储这么多单词显然是不合理的</li>
                            </ul>
                        </ul>
                    <li>方案二：幂的连乘</li>
                        <ul>
                            <li>现在，我们想通过一种算法，让cats转成数字后，不那么普通</li>
                            <li>数字相加的方案就有些过于普通了</li>
                            <li>有一种方案就是使用幂的连乘，什么是幂的连乘呢？</li>
                            <li>其实，我们平时使用的大于１０的数字，可以用一种幂的连乘来表示它的唯一性：比如，7654 = 7 * 10^3 + 6 * 10^2 + 5 * 10^1 + 4</li>
                            <li>这样得到的数字，可以基本保证它的唯一性，不会和别的单词重复</li>
                            <li>问题是：如果一个单词是ZZZZZZZZZZ(一般单词不会超过１０个字符)，那么得到的数字超过7000000000000，数组可以表示这么大的下标值吗？</li>
                                <ul>
                                    <li>内存分配不了这么大的数组，数组是连续占用内存控件的</li>
                                    <li>而且，就算能创建这么打的数组，事实上有很多是无效的单词</li>
                                    <li>创建这么大的数组是没有意义的</li>
                                </ul>
                            <li>幂的连乘，保证了唯一性，但是也极大的造成了内存控件的浪费</li>
                        </ul>
                    <li>两个方案总结</li>
                        <ul>
                            <li>第一种方案：把数字相加求和，产生的数组下标太少</li>
                            <li>第二种方案：与２７的幂相乘求和，产生的数组下标又太多了</li>
                        </ul>
                </ul>
            </ul>
        </div>
        <div>
            <h2>哈希化的一些概念</h2>
            <ul>
                <li><strong>哈希化: </strong>将大数字转化成数组范围内下标的过程,我们就称为哈希化</li>
                <li><strong>哈希函数: </strong>通常我们会将单词转成大数字,大数字在进行哈希化的代码实现放在一个函数中,这个函数我们称为哈希函数</li>
                <li><strong>哈希表: </strong>最终将数据插入到的这个数组,对整个结果的封装,我们称为一个哈希表.</li>
            </ul>
            <p>
                问题: 会产生冲突,而且不可避免.
                我们需要针对冲突,提出一个解决方案:
                <ol>
                    <li>链地址法,也称为拉链法</li>
                    <li>开放地址法</li>
                </ol>
            </p>
        </div>
        <div>
            <p>
                链地址法（拉链法）
                数组中存放的不是数值本身，而是链条；
                这个链条可以使用数组或者linked list来组织数据；
                比如是linked list的话，也就是每个数组单元中存储着一个链表，一旦发现重复，将重复的元素插入到链表的首端或者末端即可；
                当查询时，先根据哈细化后的下标值找到对应的位置，再取出链表，依次查询数据
            </p>
            <p>
                数组还是链表呢？
                数组或者链表在这里其实都可以，效率上差不多；
                因为根据哈细化的index找出这个数组或者链表时，通常就会使用线性查找，这个时候数组和链表的效率是差不多的；
                当然在某些视线中，会将新插入的数据放在数组或者链表的最前面，因为觉得新插入的数据用于取出的可能性更大；
                这种情况最好采用链表，因为数组在首位插入数据是需要所有其他项后移的，链表就没有这样的问题；
                当然，如何选择也看业务需求，不见得新的数据就访问次数会更多：比如，我们微信新添加的好友，可能是刚认识的，
                联系的频率不见得比我们老朋友更多，甚至新加的只是聊上一两句．
                所以，这里选择数组还是链表，都可以
            </p>
        </div>
        <div>
            <p>
                开放地址法
                主要工作方式是寻找空白的单元格来添加重复的数据
                但是，探索这个位置的方式不同，有三种方法：
                <ul>
                    <li>线性探测</li>
                    <li>二次探测</li>
                    <li>再哈希法</li>
                </ul>
            </p>
            <p>
                线性探测
                即为，线性的查找空白的单元
                比如，要插入32这个数，经过哈希化后得到的index = 2，但是在插入的时候，发现该位置已经有了82这个值，
                那么，线性探测就是从index位置 + 1开始，一点点查找合适的位置来放置32，什么是合适的位置？
                空的位置就是合适的位置，比如说，index = 3时发现是空的位置，那么这个时候32就放在该位置．
                那么，如何查询32？
                首先经过哈希化得到index = 2，比如2的位置结果和查询的数值是否相同，相同那么就直接返回
                不相同呢？就开始线性查找，从index + 1开始查找
                这里有一个特别需要注意的地方：如果32的位置我们之前没有插入，是否将这个哈希表查询一遍来确定32存不存在呢？
                当然不是，查询过程有一个约定，就是查询到空位置，就停止
                因为查询到这里有空位置，32之前不可能跳到空位置去其他的位置．
            </p>
            <p>
                删除３２呢？
                删除操作和插入查询比较类似，但是也有一个特别注意点
                注意：删除操作一个数据项时，不可以将这个位置下标的内容设置为null,为什么呢？
                因为将它设置为null可能会影响我们之后查询其他操作，所以通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如，设置为-1）
                当我们之后看到-1位置的数据项时，就知道查询时要继续查询，但是插入时这个位置可以放置数据
            </p>
            <p>
                线性探测的问题
                线性探测有一个比较严重的问题，就是聚集．什么是聚集呢？
                比如，我在没有任何数据的时候，插入的是22-23-24-25-26，那么意味着下标值：2-3-4-5-6的位置都有元素
                这种一连串填充单元就叫做聚集．
                聚集会影响哈希表的性能，无论是插入/查询/删除都会影响．
                比如，我们插入一个32，会发现连续的单元都不允许我们放置数据，并且在这个过程中我们需要探索多次
                二次探测，可以解决一部分这个问题
            </p>
            <p>
                二次探测法
                二次探测法就是在线性探测的基础上进行的优化：
                二次探测主要优化的是探测时的步长，什么意思呢？
                线性探测，我们可以看成是步长为１的探测，比如从下标值x开始，那么线性测试就是从 x+1, x+2, x+3依次探测
                二次探测，对步长做了优化，比如从下标值x开始，x+1^2, x+2^2, x+3^2
                这样就可以一次性探测比较长的距离，比避免那些聚集带来的影响
            </p>
            <p>
                二次探测的问题：
                但是二次探测依然存在问题，比如我们连续插入的是32-112-82-2-192，那么它们一次累加的时候，步长相同
                也就是这种情况下，会造成步长不一的一种聚集，还是会影响效率（当然这种可能性相对于连续的数字会小一些）
                怎么根本解决这个问题呢？
                让每个人的步长不一样，一起来看看再哈希法吧
            </p>
            <p>
                再哈希法：　
                为了消除线性探测和二次探测中，无论步长+1，还是步长+平法中存在的问题，还有一种最常用的解决方案：再哈希法
                再哈希法：
                二次探测的算法产生的探测序列步长是固定的：１，４，９，１６，．．．依次类推
                现在需要一种方法：产生一种依赖关键字的探测序列，而不是每个关键字都一样
                那么，不同的关键字，即使映射到相同的数组下标，也可以使用不同的探测序列
                再哈希法的做法就是：把关键字用另外一个哈希函数，再做一次哈希化，用这次哈希化的结果作为步长
                对于指定的关键字，步长在整个探测中是不变的，不过不同的关键字使用不同的步长
            </p>
            <p>
                第二次哈希化需要具备如下特点：
                和第一次哈希函数不同（不要再使用上一次的哈希函数了，不然结果还是原来的位置）
                不能输出为０（否则，将没有步长，每次探测都是原地踏步，算法就进入了死循环）
            </p>
            <p>
                其实，我们不用费脑细胞来设计，计算机专家已经设计出一种工作很好的哈希函数：
                <ul>
                    <li>stepSize = constant - (key % constant) </li>
                    <li>其中，constant是质数，且小于数组的容量</li>
                    <li>例如，stepSize = 5 - (key % 5)，满足需求，并且结果不可能为０</li>
                </ul>
            </p>
        </div>

    </body>
</html>








